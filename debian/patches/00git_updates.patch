diff --git a/RELEASE b/RELEASE
index 81c537e..ccd9f0c 100644
--- a/libupower-glib/up-device.c
+++ b/libupower-glib/up-device.c
@@ -85,6 +85,7 @@ struct _UpDevicePrivate
 	gint64			 time_to_empty;		/* seconds */
 	gint64			 time_to_full;		/* seconds */
 	gdouble			 percentage;		/* percent */
+	gdouble			 temperature;		/* degrees C */
 	gboolean		 recall_notice;
 	gchar			*recall_vendor;
 	gchar			*recall_url;
@@ -117,6 +118,7 @@ enum {
 	PROP_TIME_TO_EMPTY,
 	PROP_TIME_TO_FULL,
 	PROP_PERCENTAGE,
+	PROP_TEMPERATURE,
 	PROP_RECALL_NOTICE,
 	PROP_RECALL_VENDOR,
 	PROP_RECALL_URL,
@@ -205,6 +207,8 @@ up_device_collect_props_cb (const char *key, const GValue *value, UpDevice *devi
 		device->priv->time_to_empty = g_value_get_int64 (value);
 	} else if (g_strcmp0 (key, "Percentage") == 0) {
 		device->priv->percentage = g_value_get_double (value);
+	} else if (g_strcmp0 (key, "Temperature") == 0) {
+		device->priv->temperature = g_value_get_double (value);
 	} else if (g_strcmp0 (key, "Technology") == 0) {
 		device->priv->technology = g_value_get_uint (value);
 	} else if (g_strcmp0 (key, "IsPresent") == 0) {
@@ -512,6 +516,8 @@ up_device_to_text (UpDevice *device)
 	    device->priv->kind == UP_DEVICE_KIND_UPS)
 		g_string_append_printf (string, "    percentage:          %g%%\n", device->priv->percentage);
 	if (device->priv->kind == UP_DEVICE_KIND_BATTERY) {
+		if (device->priv->temperature > 0)
+			g_string_append_printf (string, "    temperature:         %g degrees C\n", device->priv->temperature);
 		if (device->priv->capacity > 0)
 			g_string_append_printf (string, "    capacity:            %g%%\n", device->priv->capacity);
 	}
@@ -586,7 +592,9 @@ out:
  *
  * Gets the device history.
  *
- * Return value: (transfer full): an array of #UpHistoryItem's, else #NULL and @error is used
+ * Return value: (transfer full): an array of #UpHistoryItem's, with the most
+ *               recent one being first; %NULL if @error is set or @device is
+ *               invalid
  *
  * Since: 0.9.0
  **/
@@ -827,6 +835,9 @@ up_device_set_property (GObject *object, guint prop_id, const GValue *value, GPa
 	case PROP_PERCENTAGE:
 		device->priv->percentage = g_value_get_double (value);
 		break;
+	case PROP_TEMPERATURE:
+		device->priv->temperature = g_value_get_double (value);
+		break;
 	case PROP_TECHNOLOGY:
 		device->priv->technology = g_value_get_uint (value);
 		break;
@@ -931,6 +942,9 @@ up_device_get_property (GObject *object, guint prop_id, GValue *value, GParamSpe
 	case PROP_PERCENTAGE:
 		g_value_set_double (value, device->priv->percentage);
 		break;
+	case PROP_TEMPERATURE:
+		g_value_set_double (value, device->priv->temperature);
+		break;
 	case PROP_RECALL_NOTICE:
 		g_value_set_boolean (value, device->priv->recall_notice);
 		break;
@@ -1298,6 +1312,18 @@ up_device_class_init (UpDeviceClass *klass)
 							      0.0, 100.f, 100.0,
 							      G_PARAM_READWRITE));
 	/**
+	 * UpDevice:temperature:
+	 *
+	 * The temperature of the device in degrees Celsius.
+	 *
+	 * Since: 0.9.22
+	 **/
+	g_object_class_install_property (object_class,
+					 PROP_TEMPERATURE,
+					 g_param_spec_double ("temperature", NULL, NULL,
+							      0.0, G_MAXDOUBLE, 0.0,
+							      G_PARAM_READWRITE));
+	/**
 	 * UpDevice:recall-notice:
 	 *
 	 * If the device may be recalled due to defect. NOTE: This property does
diff --git a/src/linux/hidpp-test.c b/src/linux/hidpp-test.c
index 5ae85ce..d23582e 100644
--- a/src/linux/hidpp-test.c
+++ b/src/linux/hidpp-test.c
@@ -39,7 +39,9 @@ main (int argc, char **argv)
 	gboolean ret;
 	GError *error = NULL;
 
+#if !defined(GLIB_VERSION_2_36)
 	g_type_init ();
+#endif
 	g_test_init (&argc, &argv, NULL);
 
 	d = hidpp_device_new ();
diff --git a/src/linux/integration-test b/src/linux/integration-test
index b80dd70..e3cf290 100755
--- a/src/linux/integration-test
+++ b/src/linux/integration-test
@@ -376,6 +376,7 @@ class Tests(unittest.TestCase):
         self.assertEqual(self.get_dbus_dev_property(bat0_up, 'EnergyFull'), 126.0)
         self.assertEqual(self.get_dbus_dev_property(bat0_up, 'EnergyFullDesign'), 132.0)
         self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Voltage'), 12.0)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Temperature'), 0.0)
         self.assertEqual(self.get_dbus_dev_property(bat0_up, 'NativePath'), bat0)
         self.stop_daemon()
 
@@ -408,6 +409,61 @@ class Tests(unittest.TestCase):
         self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Percentage'), 40.0)
         self.stop_daemon()
 
+    def test_battery_capacity_and_charge(self):
+        '''battery which reports capacity and charge_full'''
+
+        bat0 = self.testbed.add_device('power_supply', 'BAT0', None,
+                ['type', 'Battery',
+                 'present', '1',
+                 'status', 'Discharging',
+                 'charge_full', '10500000',
+                 'charge_full_design', '11000000',
+                 'capacity', '40',
+                 'voltage_now', '12000000'], [])
+
+        self.start_daemon()
+        devs = self.proxy.EnumerateDevices()
+        self.assertEqual(len(devs), 1)
+        bat0_up = devs[0]
+
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Percentage'), 40.0)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'IsPresent'), True)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'State'), UP_DEVICE_STATE_DISCHARGING)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Energy'), 50.4)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'EnergyFull'), 126.0)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'EnergyFullDesign'), 132.0)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Voltage'), 12.0)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'NativePath'), bat0)
+
+        self.assertEqual(self.get_dbus_property('OnBattery'), True)
+        self.assertEqual(self.get_dbus_property('OnLowBattery'), False)
+        self.stop_daemon()
+
+    def test_battery_temperature(self):
+        '''battery which reports temperature'''
+
+        bat0 = self.testbed.add_device('power_supply', 'BAT0', None,
+                ['type', 'Battery',
+                 'present', '1',
+                 'status', 'Discharging',
+                 'temp', '254',
+                 'energy_full', '60000000',
+                 'energy_full_design', '80000000',
+                 'energy_now', '1500000',
+                 'voltage_now', '12000000'], [])
+
+        self.start_daemon()
+        devs = self.proxy.EnumerateDevices()
+        self.assertEqual(len(devs), 1)
+        bat0_up = devs[0]
+
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Temperature'), 25.4)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Percentage'), 2.5)
+        self.assertEqual(self.get_dbus_dev_property(bat0_up, 'Energy'), 1.5)
+        self.assertEqual(self.get_dbus_property('OnBattery'), True)
+        self.assertEqual(self.get_dbus_property('OnLowBattery'), True)
+        self.stop_daemon()
+
     def test_ups_ac(self):
         '''UPS properties with and without AC'''
 
diff --git a/src/linux/up-device-supply.c b/src/linux/up-device-supply.c
index bd54801..a93d16a 100644
--- a/src/linux/up-device-supply.c
+++ b/src/linux/up-device-supply.c
@@ -134,6 +134,7 @@ up_device_supply_reset_values (UpDeviceSupply *supply)
 		      "time-to-empty", (gint64) 0,
 		      "time-to-full", (gint64) 0,
 		      "percentage", (gdouble) 0.0,
+		      "temperature", (gdouble) 0.0,
 		      "technology", UP_DEVICE_TECHNOLOGY_UNKNOWN,
 		      NULL);
 }
@@ -406,14 +407,14 @@ up_device_supply_get_design_voltage (const gchar *native_path)
 
 	/* is this a USB device? */
 	device_type = up_device_supply_get_string (native_path, "type");
-	if (g_ascii_strcasecmp (device_type, "USB") == 0) {
+	if (device_type != NULL && g_ascii_strcasecmp (device_type, "USB") == 0) {
 		g_debug ("USB device, so assuming 5v");
 		voltage = 5.0f;
 		goto out;
 	}
 
 	/* completely guess, to avoid getting zero values */
-	g_warning ("no voltage values, using 10V as approximation");
+	g_warning ("no voltage values for device %s, using 10V as approximation", native_path);
 	voltage = 10.0f;
 out:
 	g_free (device_type);
@@ -490,6 +491,7 @@ up_device_supply_refresh_battery (UpDeviceSupply *supply)
 	gdouble voltage;
 	gint64 time_to_empty;
 	gint64 time_to_full;
+	gdouble temp;
 	gchar *manufacturer = NULL;
 	gchar *model_name = NULL;
 	gchar *serial_number = NULL;
@@ -693,7 +695,12 @@ up_device_supply_refresh_battery (UpDeviceSupply *supply)
 		energy_rate = up_device_supply_calculate_rate (supply, energy);
 
 	/* get a precise percentage */
-	if (energy_full > 0.0f) {
+        if (sysfs_file_exists (native_path, "capacity")) {
+		percentage = sysfs_get_double (native_path, "capacity");
+                /* for devices which provide capacity, but not {energy,charge}_now */
+                if (energy < 0.1f && energy_full > 0.0f)
+                    energy = energy_full * percentage / 100;
+        } else if (energy_full > 0.0f) {
 		percentage = 100.0 * energy / energy_full;
 		if (percentage < 0.0f)
 			percentage = 0.0f;
@@ -701,13 +708,6 @@ up_device_supply_refresh_battery (UpDeviceSupply *supply)
 			percentage = 100.0f;
 	}
 
-	/* device is a peripheral and not providing power to the computer */
-	if (energy < 0.01f &&
-	    energy_rate < 0.01f &&
-	    energy_full < 0.01f) {
-		percentage = sysfs_get_double (native_path, "capacity");
-	}
-
 	/* the battery isn't charging or discharging, it's just
 	 * sitting there half full doing nothing: try to guess a state */
 	if (state == UP_DEVICE_STATE_UNKNOWN) {
@@ -787,6 +787,9 @@ up_device_supply_refresh_battery (UpDeviceSupply *supply)
 	if (time_to_full > (20 * 60 * 60)) /* 20 hours for charging */
 		time_to_full = 0;
 
+	/* get temperature */
+	temp = sysfs_get_double(native_path, "temp") / 10.0;
+
 	/* check if the energy value has changed and, if that's the case,
 	 * store the new values in the buffer. */
 	if (up_device_supply_push_new_energy (supply, energy))
@@ -813,6 +816,7 @@ up_device_supply_refresh_battery (UpDeviceSupply *supply)
 		      "voltage", voltage,
 		      "time-to-empty", time_to_empty,
 		      "time-to-full", time_to_full,
+		      "temperature", temp,
 		      NULL);
 
 out:
diff --git a/src/org.freedesktop.UPower.Device.xml b/src/org.freedesktop.UPower.Device.xml
index 04ea4da..0be009c 100644
--- a/src/org.freedesktop.UPower.Device.xml
+++ b/src/org.freedesktop.UPower.Device.xml
@@ -544,6 +544,19 @@ method return sender=:1.386 -> dest=:1.477 reply_serial=2
       </doc:doc>
     </property>
 
+    <property name="Temperature" type="d" access="read">
+      <doc:doc>
+        <doc:description>
+          <doc:para>
+            The temperature of the device in degrees Celsius. This property is
+            only valid if the property
+            <doc:ref type="property" to="Source:Type">type</doc:ref>
+            has the value "battery".
+          </doc:para>
+        </doc:description>
+      </doc:doc>
+    </property>
+
     <property name="IsPresent" type="b" access="read">
       <doc:doc>
         <doc:description>
diff --git a/src/up-device.c b/src/up-device.c
index 12f32ff..9e9c332 100644
--- a/src/up-device.c
+++ b/src/up-device.c
@@ -77,6 +77,7 @@ struct UpDevicePrivate
 	gint64			 time_to_empty;		/* seconds */
 	gint64			 time_to_full;		/* seconds */
 	gdouble			 percentage;		/* percent */
+	gdouble			 temperature;		/* degrees C */
 	gboolean		 recall_notice;
 	gchar			*recall_vendor;
 	gchar			*recall_url;
@@ -110,6 +111,7 @@ enum {
 	PROP_TIME_TO_EMPTY,
 	PROP_TIME_TO_FULL,
 	PROP_PERCENTAGE,
+	PROP_TEMPERATURE,
 	PROP_TECHNOLOGY,
 	PROP_RECALL_NOTICE,
 	PROP_RECALL_VENDOR,
@@ -249,6 +251,9 @@ up_device_get_property (GObject *object, guint prop_id, GValue *value, GParamSpe
 	case PROP_PERCENTAGE:
 		g_value_set_double (value, device->priv->percentage);
 		break;
+	case PROP_TEMPERATURE:
+		g_value_set_double (value, device->priv->temperature);
+		break;
 	case PROP_TECHNOLOGY:
 		g_value_set_uint (value, device->priv->technology);
 		break;
@@ -352,6 +357,9 @@ up_device_set_property (GObject *object, guint prop_id, const GValue *value, GPa
 	case PROP_PERCENTAGE:
 		device->priv->percentage = g_value_get_double (value);
 		break;
+	case PROP_TEMPERATURE:
+		device->priv->temperature = g_value_get_double (value);
+		break;
 	case PROP_TECHNOLOGY:
 		device->priv->technology = g_value_get_uint (value);
 		break;
@@ -1170,6 +1178,14 @@ up_device_class_init (UpDeviceClass *klass)
 							      0.0, 100.f, 100.0,
 							      G_PARAM_READWRITE));
 	/**
+	 * UpDevice:temperature:
+	 */
+	g_object_class_install_property (object_class,
+					 PROP_TEMPERATURE,
+					 g_param_spec_double ("temperature", NULL, NULL,
+							      0.0, G_MAXDOUBLE, 0.0,
+							      G_PARAM_READWRITE));
+	/**
 	 * UpDevice:recall-notice:
 	 */
 	g_object_class_install_property (object_class,
diff --git a/src/up-history.c b/src/up-history.c
index cd16f36..c16b3c1 100644
--- a/src/up-history.c
+++ b/src/up-history.c
@@ -121,7 +121,7 @@ up_history_array_limit_resolution (GPtrArray *array, guint max_num)
 	UpHistoryItem *item_new;
 	gfloat division;
 	guint length;
-	gint i;
+	guint i;
 	guint last;
 	guint first;
 	GPtrArray *new;
@@ -157,7 +157,7 @@ up_history_array_limit_resolution (GPtrArray *array, guint max_num)
 	/* Reduces the number of points to a pre-set level using a time
 	 * division algorithm so we don't keep diluting the previous
 	 * data with a conventional 1-in-x type algorithm. */
-	for (i=length-1; i>=0; i--) {
+	for (i = 0; i < length; i++) {
 		item = (UpHistoryItem *) g_ptr_array_index (array, i);
 		preset = last + (division * (gfloat) step);
 
diff --git a/src/up-main.c b/src/up-main.c
index 6201a44..a7e6eb6 100644
--- a/src/up-main.c
+++ b/src/up-main.c
@@ -204,7 +204,9 @@ main (gint argc, gchar **argv)
 		{ NULL}
 	};
 
+#if !defined(GLIB_VERSION_2_36)
 	g_type_init ();
+#endif
 
 	context = g_option_context_new ("upower daemon");
 	g_option_context_add_main_entries (context, options, NULL);
diff --git a/src/up-self-test.c b/src/up-self-test.c
index d19734e..1a0595d 100644
--- a/src/up-self-test.c
+++ b/src/up-self-test.c
@@ -149,7 +149,7 @@ up_test_history_func (void)
 	gboolean ret;
 	GPtrArray *array;
 	gchar *filename;
-	UpHistoryItem *item;
+	UpHistoryItem *item, *item2, *item3;
 
 	history = up_history_new ();
 	g_assert (history != NULL);
@@ -171,17 +171,23 @@ up_test_history_func (void)
 	array = up_history_get_data (history, UP_HISTORY_TYPE_CHARGE, 10, 100);
 	g_assert (array != NULL);
 	g_assert_cmpint (array->len, ==, 0);
+	g_ptr_array_unref (array);
 
-	/* setup some fake device */
+	/* setup some fake device and three data points */
 	up_history_set_state (history, UP_DEVICE_STATE_CHARGING);
+	up_history_set_charge_data (history, 85);
+	up_history_set_rate_data (history, 0.99f);
+	up_history_set_time_empty_data (history, 12346);
+	up_history_set_time_full_data (history, 54322);
+
+	g_usleep (2 * G_USEC_PER_SEC);
 	up_history_set_charge_data (history, 90);
 	up_history_set_rate_data (history, 1.00f);
 	up_history_set_time_empty_data (history, 12345);
 	up_history_set_time_full_data (history, 54321);
 
-	/* sleep for a little bit */
-	g_usleep (3 * G_USEC_PER_SEC);
-	up_history_set_charge_data (history, 91);
+	g_usleep (2 * G_USEC_PER_SEC);
+	up_history_set_charge_data (history, 95);
 	up_history_set_rate_data (history, 1.01f);
 	up_history_set_time_empty_data (history, 12344);
 	up_history_set_time_full_data (history, 54320);
@@ -189,13 +195,44 @@ up_test_history_func (void)
 	/* get data for last 10 seconds */
 	array = up_history_get_data (history, UP_HISTORY_TYPE_CHARGE, 10, 100);
 	g_assert (array != NULL);
-	g_assert_cmpint (array->len, ==, 2);
+	g_assert_cmpint (array->len, ==, 3);
 
 	/* get the first item, which should be the most recent */
 	item = g_ptr_array_index (array, 0);
 	g_assert (item != NULL);
-	g_assert_cmpint (up_history_item_get_value (item), ==, 91);
+	g_assert_cmpint (up_history_item_get_value (item), ==, 95);
+	g_assert_cmpint (up_history_item_get_time (item), >, 1000000);
+
+        /* the second one ought to be older */
+	item2 = g_ptr_array_index (array, 1);
+	g_assert (item2 != NULL);
+	g_assert_cmpint (up_history_item_get_value (item2), ==, 90);
+	g_assert_cmpint (up_history_item_get_time (item2), <, up_history_item_get_time (item));
+
+        /* third one is the oldest */
+	item3 = g_ptr_array_index (array, 2);
+	g_assert (item3 != NULL);
+	g_assert_cmpint (up_history_item_get_value (item3), ==, 85);
+	g_assert_cmpint (up_history_item_get_time (item3), <, up_history_item_get_time (item2));
+
+	g_ptr_array_unref (array);
+
+        /* request fewer items than we have in our history; should have the
+         * same order: first one is the most recent, and the data gets
+         * interpolated */
+	array = up_history_get_data (history, UP_HISTORY_TYPE_CHARGE, 10, 2);
+	g_assert (array != NULL);
+	g_assert_cmpint (array->len, ==, 2);
+
+	item = g_ptr_array_index (array, 0);
+	g_assert (item != NULL);
+	item2 = g_ptr_array_index (array, 1);
+	g_assert (item2 != NULL);
+
 	g_assert_cmpint (up_history_item_get_time (item), >, 1000000);
+	g_assert_cmpint (up_history_item_get_value (item), ==, 95);
+	g_assert_cmpint (up_history_item_get_value (item2), ==, 87);
+
 	g_ptr_array_unref (array);
 
 	/* force a save to disk */
@@ -216,10 +253,10 @@ up_test_history_func (void)
 	/* get data for last 10 seconds */
 	array = up_history_get_data (history, UP_HISTORY_TYPE_CHARGE, 10, 100);
 	g_assert (array != NULL);
-	g_assert_cmpint (array->len, ==, 3); /* we have inserted an unknown as the first entry */
+	g_assert_cmpint (array->len, ==, 4); /* we have inserted an unknown as the first entry */
 	item = g_ptr_array_index (array, 1);
 	g_assert (item != NULL);
-	g_assert_cmpint (up_history_item_get_value (item), ==, 91);
+	g_assert_cmpint (up_history_item_get_value (item), ==, 95);
 	g_assert_cmpint (up_history_item_get_time (item), >, 1000000);
 	g_ptr_array_unref (array);
 
@@ -296,7 +333,9 @@ up_test_wakeups_func (void)
 int
 main (int argc, char **argv)
 {
+#if !defined(GLIB_VERSION_2_36)
 	g_type_init ();
+#endif
 	g_test_init (&argc, &argv, NULL);
 
 	/* make check, vs. make distcheck */
diff --git a/tools/up-tool.c b/tools/up-tool.c
index 87051e3..c82dae4 100644
--- a/tools/up-tool.c
+++ b/tools/up-tool.c
@@ -278,7 +278,9 @@ main (int argc, char **argv)
 		{ NULL }
 	};
 
+#if !defined(GLIB_VERSION_2_36)
 	g_type_init ();
+#endif
 
 	context = g_option_context_new ("UPower tool");
 	g_option_context_add_main_entries (context, entries, NULL);
